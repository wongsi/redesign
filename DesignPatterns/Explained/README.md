# 设计模式解析

考察常用的软件开发方法，提出开发中遇到的挑战和问题。

1.  **需求问题**

   - 用户对自己需求的看法发生改变。
   - 开发人员对用户需求的看法，会在开发过程中，因为对它更加熟悉而发生变化。

   关于需求要认识到的一点就是**需求总在变化**，这说明我们编写的代码必须要能适应变化。

2. **功能分解**，通常分析人员将问题分解成了多个功能步骤。

   * 问题1：它通常导致一个“主”程序负责控制子程序，这是将功能分解为多个子功能的自然结果。但是，主程序所承受的责任太多了。要确保一切正确工作，还要协调各函数并控制它们的先后顺序，因此，经常会产生非常复杂的代码。`委托`
   * 问题2：它在面对未来可能出现的变化，对代码改进方面，都于事无补。`变化`
   * 应对变化：与其编写一个大函数，不如使之`模块化`

3.  **模块化**，肯定有助于提供代码的可理解性，而容易理解将使代码更加容易维护。

   - 问题1：低内聚，它的任务很多而且互不相关，代码经常看上去像是令人疑惑的一大团。（内聚性指实例中操作之间联系的紧密程度，一个类的多个操作联系越紧密，就越容易理解其含义，也称清晰性。）
   - 问题2：紧耦合（耦合性指两个实例之间联系的紧密程度。）
   - `不良副作用` 即，修改某处，虽然获得了希望的结果，但也得到了不需要的结果——隐错。
   - `维护和调试的时间` 大多数时间被用于努力弄清代码的运作机理、寻找隐错和防止出现不良副作用。

   使用功能分解时，需求变更会对软件开发和维护工作产生极大影响。这时候，主要的精力都放在函数上了，而对一组函数或数据的修改会影响到其它函数和数据，并依此类推地影响到其它必须修改的函数。就像一个雪球滚下山来，一路裹挟了更多的雪一样。只关注函数，将导致一连串变化，而且难以避免。`功能分解将注意力放在错误的地方`

## 应对需求变更

方法1 直接指示每个人，必须密切关注大量细节，没有其他人负责。

方法2 只给出通用的提示，然后期待其他人自己弄清怎么完成任务。

* 责任转移

  * 人们对自己的行为负责，而不再由控制程序负责决定他们的行为。

  * 控制程序可以与不同类型的人交流，好像他们都一样。
  * 控制程序不需要知道完成任务的任何特殊步骤。

* 软件开发过程中的视角
  * 概念：`软件要负责什么？` 研究领域种的各种概念，得出概念模型时应该很少或者不考虑实现它的软件。
  * 规约：`怎么使用软件？` 考虑软件，关注软件的接口，而不是实现。 
  * 实现：`软件怎么履行自己的责任？` 这时考虑的是软件本身。
  
  在一个层次（概念）上交流，而在另一个层次（实现）上执行，这样调用者就无需知道具体细节了。

